---
title: Feature Comparison with GAS
layout: home
parent: Introduction
nav_order: 1
---

# Feature comparison with Epic's GAS

| **Feature** | **GAS** | **SimpleGAS**  |
| ----- | ----- | ----- |
| **Ability Definition & Activation** | **Gameplay Ability** classes with `ActivateAbility()` (C++ or Blueprint override). Can auto-activate via input or triggers. Activation can be **predictive** or server-authoritative based on how it's invoked. | **SimpleGameplayAbility** classes with `OnActivate` (BlueprintImplementableEvent). Activation is controlled by an **ActivationPolicy** (LocalOnly, ClientPredicted, ServerOnly, etc.) set per ability. This explicit policy makes it clear how the ability runs (locally, on server, or both), simplifying usage. |
| **Ability Instancing**          | Supports multiple instances: abilities have an `InstancingPolicy`. By default, each activation creates a new instance unless marked as `NonInstanced`. The system can run the same ability multiple times concurrently if allowed. | Supports **SingleInstance** or **MultipleInstances** per ability class. SingleInstance will reuse one object; if re-activated while running, SimpleGAS cancels the old one by default. MultipleInstances creates a new object each time. SimpleGAS prevents concurrent activations of a SingleInstance ability unless cancellation is allowed. |
| **Ability Tags & Requirements** | Uses **Gameplay Tags** heavily. Abilities have Activation Required/Blocked tag containers; the ASC (AbilitySystemComponent) checks these before activating an ability. Abilities can also grant or remove tags (e.g. apply a gameplay effect that adds a tag). | Supports tag requirements in a simpler form. Each SimpleGameplayAbility can have `ActivationRequiredTags` and `ActivationBlockingTags`, and the component's `MeetsActivationRequirements()` checks them on activation. Abilities can specify tags to add/remove on start: SimpleGAS uses **TemporarilyAppliedTags** and **PermanentlyAppliedTags** that the component adds on activation and removes on end. This is conceptually similar to GAS's tag application via GameplayEffects, but more direct. |
| **Attributes System**           | Attributes are defined in **AttributeSet** classes as UPROPERTYs. Changes to attributes are done via **GameplayEffects**, which can modify attributes with modifiers (add, multiply, etc.). Attributes replicate via their AttributeSet (with modes Full/Mixed/Minimal replication). Meta-attributes exist for things like damage or healing to funnel final calculations. Attributes are Float values only. | Attributes are defined directly on the Ability Component (optionally `AttributeSet`'s can share common attribute definitions between actors). Each attribute has a GameplayTag as an identifier and accompanying data. Modifying attributes can be done directly (e.g. `SetFloatAttributeValue`) or through SimpleGAS's **Attribute Modifiers** (analogous to GameplayEffects). Attributes can be Floats or Structs|
| **Attribute Modification**      | **GameplayEffects (GEs)**: Configurable objects that define attribute modifications (instant or over time) and other effects (like granting tags or triggering gameplay cues). GEs can have durations, periodic ticks, and conditional modifiers. Client prediction is supported for GEs (predictive instant effects, etc.) with sophisticated rollback if mispredicted. Magnitude of modifications can be calculated via formulas or attribute aggregators. | **Simple Attribute Modifiers**: These are classes (`USimpleAttributeModifier`) that act like simplified GameplayEffects. A modifier can apply changes to one or more attributes on a target. They support **Instant** or **Duration** types and stacking. For instance, a "Damage over Time" could be a Duration modifier ticking every few seconds. SimpleGAS handles modifiers through the Ability Component: you call `ApplyAttributeModifierToTarget` to create and apply one. Under the hood, this spawns a `USimpleAttributeModifier` object (if not already existing for single-instance) and calls its `ApplyModifier()` logic. Unlike GAS's external GameplayEffect specs, SimpleGAS modifiers are blueprintable classes with lifecycle events (`OnPreApplyModifier`, `OnPostApplyModifier`, etc.). This is more explicit and easier to debug in Blueprint, though less data-driven. |
| **Client-side Prediction**      | High support for prediction: abilities can be activated on the client and will predictively apply GameplayEffects. GAS uses a **Prediction Key** system to match client actions with server outcomes, and has explicit RPCs for confirm/cancel. Mis-predictions trigger rollbacks or corrections (e.g. client spawn an effect, server rejects it -> client removes it). This makes GAS robust in high-lag scenarios but it's complex. | Supports prediction in a **simpler snapshot-based** way. If an ability or modifier is marked `ClientPredicted`, the client runs it immediately and the server is notified (e.g. via `ServerActivateAbility` RPC in SimpleGAS). The server then replicates the authoritative state. SimpleGAS uses **AbilityState Snapshots** to reconcile differences: the client and server each capture snapshots of important moments or results (using `TakeStateSnapshot` in ability code). If the server's snapshot differs, the client's ability is informed via `ClientResolvePastState` to correct, or `ClientFastForwardState` if the client was behind. This is analogous to GAS's confirm/rollback but handled with data comparisons rather than explicit event RPCs. It is more developer-friendly (just take snapshots when needed and handle one function to resolve), but not as granular as Epic's system. |
| **Gameplay Cues / Effects Visualization** | Has a dedicated **GameplayCue** system. GameplayCues are essentially cosmetic events (like particle or sound effects) triggered by GameplayEffects. They are implemented as separate assets or Blueprint classes and can be executed on clients based on GameplayTags (e.g. "GameplayCue.FireBlast.Hit" could spawn a fire impact effect). GAS can batch cues and has a replication system optimized for them (so cosmetic effects don't tax game logic). | No explicit GameplayCue system. SimpleGAS relies on the developer to trigger cosmetic effects through ability or modifier logic. Since abilities are regular Blueprint classes, you can directly spawn emitters, play sounds, etc., in `OnActivate` or via SimpleGAS's **SimpleEventSubsystem** (which can broadcast events to other systems or Blueprints). While this is straightforward, it isn't as modular as GameplayCues. A developer could mimic cues by sending replicated events (SimpleGAS does have `SendEvent()` in abilities and the event subsystem to listen for tags), but there's no built-in separation of cosmetic logic like in GAS. On the flip side, SimpleGAS's approach is very _WYSIWYG_: what you script in the ability is what happens. |
| **Cooldowns & Costs**           | Typically implemented via GameplayEffects: e.g. apply a GameplayEffect that adds a "Cooldown" tag or modifies a cooldown attribute, and UI queries that. Costs (mana, stamina) are checked via attributes and can prevent ability activation if not enough. GAS provides `CommitAbility()` which deducts cost and applies cooldown in one go (and can roll them back on cancel). | Provides simple cooldown tracking per ability class. Each ability has a `Cooldown` float property (in seconds). The component tracks the last activation time for each ability class in `LastActivatedAbilityTimeStamps`. On activation, it checks if `LastTime + Cooldown > current server time`; if so, it refuses activation. This is lightweight compared to GAS's GameplayEffect method. It's easy to query (`IsAbilityOnCooldown()` and `GetAbilityCooldownTimeRemaining()` are provided). However, it lacks the granularity of GAS â€“ e.g. GAS could have cooldowns that reduce with modifiers or by tags, whereas SimpleGAS cooldown is a fixed time window. Ability **costs** in SimpleGAS would be implemented manually in the ability (e.g. subtracting an attribute like mana in OnActivate). There's no built-in cost commit function, but you can simply use the attribute functions to deduct cost and check values before activation (possibly in `MeetsActivationRequirements()`). |
| **Execution Model**            | **Gameplay Ability execution** often uses **GameplayTasks** (like `UAbilityTask_WaitTargetData`, `UAbilityTask_PlayMontage`, etc.) to handle asynchronous parts. Abilities can be stateful (with ability states/phases managed via tasks or manual state variables) and can yield execution until tasks complete. This is powerful for complex abilities (e.g. wait for user targeting, then apply effect, then wait for cooldown, etc.), but requires understanding the task system. | **Simple Ability execution** can be handled in standard Blueprint flow. Because SimpleGAS abilities are `Tickable` (optional) and can use timers or the provided Async Actions, designers typically manage ability flow with Blueprint logic (e.g. use a Delay node, or call `WaitForEvent` from the SimpleEventSubsystem). The plugin provides **Async Blueprint Actions** like `WaitForAbilityEnded` or `WaitForFloatAttributeChange` (similar to ability tasks) to help orchestrate ability flow in Blueprint, which are easier to use but less numerous than GAS's task library. In short, SimpleGAS favors a **blueprint script** approach (you write the sequence of events in the ability's OnActivate using latent nodes or Async Actions), whereas GAS encourages using AbilityTasks which encapsulate common patterns. SimpleGAS's approach is very transparent to a Blueprint designer, at the cost of manually handling some sequences that GAS might handle internally. |
| **Replication Mode Control**   | The AbilitySystemComponent in GAS can operate in **Full, Mixed, or Minimal** replication mode, allowing developers to tune how much data is replicated (e.g. Minimal mode doesn't replicate GameplayEffects, only critical tags and cues, to save bandwidth for AI pawns). This is an advanced optimization in GAS for large-scale games. | No direct equivalent. SimpleGAS always replicates the Authority states (abilities, attributes, tags) to all clients (or potentially owner only if adjusted). There isn't a built-in toggle to reduce what is replicated â€“ developers would need to manually customize which properties replicate. Because SimpleGAS is intended for simpler use cases, this fine-grained control isn't exposed, though one could modify replication conditions on the UPROPERTYs or not replicate certain modifiers if not needed. |
| **Complexity vs. Usability**   | High complexity, steep learning curve. Requires understanding of concepts like GameplayEffect specifiers, prediction keys, attribute sets, GameplayTags nuances, etc. However, it's extremely powerful and scalable; nearly any RPG or shooter mechanic can be built by configuring GAS assets. It's mostly code-driven with some Blueprint support for abilities and effects. Beginners often struggle with the boilerplate (e.g. setting up ASC in characters, granting abilities, making sure replication mode is correct). | Designed for **developer-friendliness and Blueprint usability**. Setting up SimpleGAS involves adding the component and creating Ability/Modifier Blueprint classes. The concepts map to concrete gameplay ideas (an Ability class for each ability, an AttributeModifier for each effect type). There is less "magic" â€“ e.g. no concept of prediction keys or scoped modifiers â€“ making it easier to reason about in small projects. The trade-off is flexibility: SimpleGAS might require more custom logic in Blueprint for things GAS does automatically (like replication of an effect only to certain players or sophisticated stacking rules). For many projects that don't need the full generality of GAS, SimpleGAS can be much more straightforward, especially in Blueprint-only environments. |